#! /usr/bin/env node
'use strict';

const fs = require('fs');
const path = require('path');
const printf = require('fast-printf').printf;
const { spawnSync } = require("child_process");
const colors = require('colors'); // unsafe, modifies String prototype

async function main () {
    const arg = process.argv[2]; // 0 = node, 1 = script
    if (arg === undefined)
        console.log(`Usage: ${process.argv[1]} <all|FILE>`);
    else if (arg === 'all')
        await run_all_tests();
    else if (fs.existsSync(arg) && arg.endsWith('.wasm'))
        await run_file(arg, {stdout: true});
    else
        console.error("Invalid argument", arg, "must be an existing WASM file or word 'all'");
}

async function run_all_tests () {
    const wat_dir = path.resolve(__dirname, '..', 'tests', 'wat');
    const wasm_dir = path.resolve(__dirname, '..', 'tests', 'wasm');
    const c_dir = path.resolve(__dirname, '..', 'tests', 'c');

    fs.mkdirSync(wasm_dir, {recursive: true}); // option 'recursive' prevents error when directory exists

    const wat_files = fs.readdirSync(wat_dir);

    console.log("⦿ Compilation".cyan);

    const compilation = [];
    for (const wat of wat_files) {
        const res = spawnSync('wat2wasm',
            [path.resolve(wat_dir, wat),
                '-o', path.resolve(wasm_dir, wat.replace('.wat', '.wasm'))], {
                cwd: process.cwd(),
                env: process.env,
                stdio: [process.stdin, process.stdout, process.stderr],
                encoding: 'utf-8'
            });
        compilation.push([wat, res.status]);
    }

    for (const [wat, status] of compilation) {
        if (status === 0)
            process.stdout.write('✅ ' + wat.bold.green + "\n");
        else
            process.stdout.write('❌ ' + wat.bold.red + "\n");
    }

    console.log("\n⦿ Running".cyan);

    for (const [wat, status] of compilation) {
        const wasm = wat.replace('.wat', '.wasm');
        const c = wat.replace('.wat', '.c');
        if (/^[0-9]+-/.test(wat)) {
            const lines = fs.readFileSync(path.resolve(c_dir, c), 'utf8').split("\n");
            const expected_arr = [];
            for(let i = lines.length - 1; i >= 0; i --) {
                if (expected_arr.length === 0 && lines[i] === '')
                    continue;
                if (lines[i].startsWith('// '))
                    expected_arr.push(lines[i].substr(3) + "\n");
                else
                    break;
            }
            const expected = expected_arr.reverse().join('');
            const output = await run_file(path.resolve(wasm_dir, wasm), {stdout: false});
            if (output === expected)
                process.stdout.write('✅ ' + wasm.bold.green + "\n");
            else
                process.stdout.write('❌ ' + wasm.bold.red + "\n");

        }
    }
}

async function run_file(fname, options) {
    const target = options.stdout? process.stdout: [];

    const wasm_bytes = new Uint8Array(fs.readFileSync(fname));

    let wasm_mem;

    const read_i32 = function(mem, offset) {
        let val = 0;

        for (let i = 3; i >= 0; i --)
            val = 256 * val + mem[offset + i];
        if (mem[offset + 3] >= 128)
            val -= 2**32;
        return val;
    }

    const read_f64 = function(mem, offset) {
        console.error("read_f64 not yet implemented");
        return null;
    }

    const read_str = function(mem, offset) {
        const bytes = new Uint8Array(1024);
        let i = 0;
        while(i < 1024) {
            const c = mem[offset + i];
            if (c === 0)
                return new TextDecoder().decode(bytes.slice(0, i));
            bytes[i ++] = c;
        }
        return null;
    }

    const wasm_printf = function (offset, argc) {
        const mem = new Uint8Array(wasm_mem.buffer);
        //console.log(`printf(offset = ${offset}, argc = ${argc})`);
        //console.log(mem.slice(offset, offset + 8 * argc));

        const p_fmt = read_i32(mem, offset);
        const fmt = read_str(mem, p_fmt);
        //console.log("String address =", p_fmt);
        //console.log("Format =", fmt);

        const args = [];
        for(let i = 0; i < fmt.length - 1; i ++ ) {
            if (fmt[i] === '%') {
                i ++;
                if (fmt[i] === '%')
                    continue;
                while(i < fmt.length && !('a' <= fmt[i] && fmt[i] <= 'z' || 'A' <= fmt[i] && fmt[i] <= 'Z'))
                    i ++;
                if (i === fmt.length) {
                    console.error("Invalid format string", fmt);
                    return;
                }

                // TODO: ignoring LONG and FLOAT for mow
                offset += 8;
                if ('cdxu'.includes(fmt[i]))
                    args.push(read_i32(mem, offset))
                else if ('f'.includes(fmt[i]))
                    args.push(read_f64(mem, offset))
                else {
                    console.error("Format '" + fmt[i] + "' not known at this time");
                    return;
                }
            }
        }

        //console.log("args =", args);
        if (args.length + 1 !== argc) {
            console.error("Format string '" + fmt + "' expected", args.length,
                "substitutions, passed", argc - 1, "arguments");
            return;
        }
        const res = printf(fmt.replace('\\n', '\n'), ...args);
        // process.stdout.write();
        if (target.write)
            target.write(res);
        else if(target.push)
            target.push(res);
    }

    const wasm_instance = (await WebAssembly.instantiate(wasm_bytes, {c4wa: { printf: wasm_printf }})).instance;

    wasm_mem = wasm_instance.exports.memory;
    wasm_instance.exports.main ();

    if (!options.stdout)
        return target.join('');
}

main();
